Boas práticas
As boas práticas são fundamentais para manter a saúde do seu código, tornando sua manutenção simples e seu perfil de programador elevado.

• Colaborações são modularizadas!
• Códigos profissionais são transpilados e modularizados.
• Nunca deixe seu código em escopo global, crie funções.
• O throw new Error('..') irá lançar o erro diretamente para o catch(..).
• Sempre que precisar criar chaves privadas use o Symbol.
• Sempre desenvolva o seu código de modo particionado.
• Programar em inglês
• Recomendado utilizar camelCase.
• Sempre que possível declare utilizando const, e se fizer use maiúsculas.
• Os arquivos em JavaScript devem estar dentro da pasta js.
• Sempre selecione elementos utilizando QuerySelector.
• Sempre que possível utilize arrow function simplificada ou o mais próximo disso. 
• Se possível cada função deve executar apenas um código por vez. 
• Sempre utilizar operador de comparação estrito " === " ou " !== ".
• Sempre utilize parâmetros e argumentos em sua funções.
• Operador Ternário ou Short-Circuit pode otimizar a performance do seu código.
• Se a função tiver sinal de atribuição, é obrigatório o uso de ponto e vírgula.
• Toda vez que for usar estrutura de repetição reflita qual estrutura é a melhor escolha.
• Nunca esqueça de tratar os erros com Try, Catch( .. ) e Finally
• Não use multiplos escutadores, re-use o mesmo, isso tornará seu código mais performático (Exemplo cronômetro).
• Quando a condição tem retorno booleano, não precisa de true | false apenas retorne a condição exemplo:  return valor > 10 ao invés de um ternário.

Dicas
Informações que poderão ser úteis. 

• Formate textos com Slice( )!
• Lembre-se do Curto-Circuíto: Se ABC for true && faça isso!
• Quando trabalhar com AJAX ou Requisições (XML), considere o uso de Fetch(), torna o trabalho ainda mais simples.
• Para gerar letras use: String.fromCharCode( .. )
• Quando trabalhar com objetos ou arrays considerar o uso de atrib. por desestruturação e estruturação de dados com o uso de new Map( ).
• Só use o innerHTML se seu código contiver tags html se não, use o innerText.
• Para iterar objetos use for in para iterar arrays de modo semântico e simples for of para aplicar funções em elementos de um array forEach.
• Ao criar uma função ofereça um retorno padrão utilizando (!argumento).
• É possível criar atributos váriados como classes ou identificadores, usando apenas o setAttribute.
• Quando precisar encontrar um elemento na página, use e.target.
• Para eliminar um objeto, basta remover o elemento pai. 
• Para salvar elementos no navegador, use LocalStorage.
• Sabendo que toda função é um objeto de primeira-classe, busque usar dos seus recursos.
• Ficar atento aos métodos eles são extremamente úteis como: "eval( .. ), slice( 0, -1 )..."
• A função-construtora foi desenvolvida para criar objetos.
• Se você precisa organizar o seu programa em etapas ou criar uma sequência de execução, considere o uso de Funções Geradoras.
• Cuidado ao "guardar" arrays ou objetos, pois valores por referência são apenas indicadores de endereço na memória, portanto se houver alteração tanto na variável quanto na array, ambos modificarão o estado da memória referenciada. A única forma de duplicar uma array é criando outra igual.
• Acessar o maior número possível Number.MAX_VALUE
• O método splice( .. ) fornece muito mais autonômia na manipulação de arrays.
• Ao trabalhar com Arrays considere o uso de Filter, Map ou Reduce
• Para congelar qualquer elemento/objeto e não permitir alterações é possível utilizar o Object.freeze(..)
• Object.defineProperty para modificar as propriedades de qualquer objeto, para não criar loops trabalhe com let no this.

This
A palavra this, respeita o produto da função construtora, e não  a própria função construtora. Portanto, todo produto desta função terá o respeito da palavra this ou seja todo  objeto criado pela função construtora.

Variáveis
A variável aponta para o endereço na memória e o endereço da memória aponta para o valor.

Objetos
• Funções dentro de objetos são métodos, e métodos não precisam do "function .."
• Para configurar a entrada e saída de um método use: getters e setters
• Para modificar as suas propriedades use Object.defineProperty( .. )
• Um objeto dentro de uma variável é apenas um link para um endereço de memória.
• Para de fato copiar objetos use: let abc =  {...objeto}.
• (forEach) para manipular ou iterar objetos:   objeto.forEach(obj => obj.chave)   !Para cada laço do objeto, retorne a chave x.
• For of e métodos do Object devem ser utilizados para manipular objetos.
• Sempre que possível use notação dinâmica para atribuir e selecionar propriedades: objeto[propriedade]

Funções em Ordem Específica
• Sempre que precisar executar múltiplas funções de modo ordenado, considere Promises( .. ) com Async e Await envoltos em um Try Catch.
• Lembre-se que os parâmetros das funções também podem ser usados de modo Booleano, em conjunto do Short-Circuit -> função(true?, true?, true?){...}


Array
• É possível transformar Strings em Arrays  e aplicar funções facilmente com Array.from.

Expressões Regulares
As expressões regulares, podem facilitar muito a manipulação de Strings.

Prototypes
Sempre que estiver trabalhando com funções construtoras, faça uso de prototypes, e heranças.
!Prototype é o "local" de armazenamento de métodos, cujo acesso é restrito as instâncias da classe Mãe, a vantagem é performance, métodos são carregados a cada instância.

Validações
Busque criar as validações sempre antes do código, pois aumenta a performance.

Formulários
Sempre que for criar um formulário lembre-se da aula do professor, lá tem muitas dicas.

Erros
• Sempre que capturar um erro use new Error( .. ) para mostrá-lo.
• Para mostrar erros corretamente, use console.warn('..') ou console.error('..');

JSON e Requisições
• Quando trabalhar com AJAX ou Requisições (XML), considere o uso de Fetch() ou Axios, pois torna o trabalho ainda mais simples.
• Este é um processo client-side portanto trabalhar via navegador.
• Para ver e manipular adequadamento, o array extraído de um JSON precisa ser iterado via for of.
• Converter objetos em JSON:    JSON.stringify(objeto,'', 2);
• Converter JSON em objetos:    JSON.parse(json)

Módulos Importação | Exportação
• Considere seu uso frequente.
• Sempre apelide os nomes durante a importação | exportação.

Transpiladores
Sempre que possível transpile seu código para aumentar a compatibilidade.
• Para isso, use Webpack ou Babel (site).








NodeJS
Dicas e boas práticas.

 Importação | Exportação (Módulos)
• Para exportar ou importar use o objeto modules. 
• Para importar pacotes do NPM usamos apenas o nome: const nome = require('pacote');

NPM (Node Package Manager)
• Para instalar pacotes primeiro inicie-o: npm init -y;
• Depois, npm i pacote.
• Dev Dependecies é uma Flag que impede que packages de desenvolvedor como "Webpack" sejam enviados juntos no deploy.
• Toda versão que tiver o símbolo "^" significa que o Minor e o Patch poderão ser atualizados.
• Nomenclatura das versões: "@1.5.4"
- @         1         5         4
- Versão    Major     Minor     Patch

- Major > Uma versão completamente nova que pode afetar a compatibilidade.
- Minor > Novos recursos que não afetam a compatibilidade.
- Patch > Correção de bugs.

Manipulando o package.json:
1.  Instalar pacotes:                               npm i pacote
2.  Congela Atualização Minor e Patch:              npm i pacote -E                !remove ^
3.  Atualizar pacotes:                              npm update                     !apenas pacotes com ^
4.  Mover para devdep:                              npm i pacote --save-dev
5.  Mover para dependecies:                         npm i pacote --save-prod
6.  Instalar versão específica:                     npm i pacote@1.5.4 -E
7.  Instalar a última versão da Major específica:   npm i pacote@1.x
8.  Desinstalar um pacote:                          npm uninstal pacote
9.  Listar os pacotes instalados                    npm ls
10. Listar apenas os pacotes que você instalou:     npm ls --depth=0
11. Pacotes Desatualizados:                         npm outdated


Navegando entre Pastas
• Pasta atual a diante: ./
• Voltar uma pasta: ../
• Retorna o caminho absoluto até o arquivo atual: console.log(__filename);
• Retorna o caminho absoluto até a pasta   atual: console.log(__dirname);
• Para criar caminhos universais independente do SO: let path = require('path') | path.resolve(__dirname);


FileSystem e Path - API Node (Nativa)
Criando, analisando e manipulando arquivos do sistema.

• Para analisar arquivos do sistema, ou manipulá-los use:         require('fs').promises;                     !Promises permite manipular o retorno dos métodos(..).
• Para trabalhar com caminhos de modo mais inteligente use:       require('path');
• Para escrever dados em um arquivo:                              filesystem.writefiles(caminho,dados,opções);
• Para ler os dados de um arquivo:                                filesystem.readfiles(caminho, 'UTF8');

! Importante, sempre que importar filesystem com promises, tratá-los com then(..) ou async.
! Estude os métodos do filesystem, existem vários.




